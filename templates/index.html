<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìœ ë°©ì•” ì´ë¯¸ì§€ ë¶„ì„ ì‹œìŠ¤í…œ - XAI ê¸°ë°˜ ì„¤ëª… ê°€ëŠ¥í•œ AI</title>
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='images/team_logo.png') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700;900&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ”¬ ìœ ë°©ì•” ì´ë¯¸ì§€ ë¶„ì„ ì‹œìŠ¤í…œ</h1>
            <p class="subtitle">XAI (SHAP) ê¸°ë°˜ ì„¤ëª… ê°€ëŠ¥í•œ ì¸ê³µì§€ëŠ¥</p>
        </header>

        <main>
            <div class="examples-section">
                <h2>ğŸ“¸ ì˜ˆì‹œ ì´ë¯¸ì§€</h2>
                <p class="examples-intro">ì•„ë˜ ì˜ˆì‹œë¥¼ ì°¸ê³ í•˜ì—¬ ì–‘ì„±ê³¼ ì•…ì„± ì„¸í¬ì˜ ì°¨ì´ë¥¼ í™•ì¸í•˜ì„¸ìš”</p>
                <div class="examples-grid">
                    <div class="example-card benign-example">
                        <div class="example-header">
                            <div class="example-badge benign-badge">ì–‘ì„± (Benign)</div>
                        </div>
                        <div class="example-image-container">
                            <img src="{{ url_for('static', filename='images/benign_ex.png') }}" alt="ì–‘ì„± ì„¸í¬ ì˜ˆì‹œ" class="example-image">
                            <div class="image-overlay">
                                <div class="overlay-content">
                                    <h3>ì–‘ì„± ì„¸í¬ íŠ¹ì§•</h3>
                                    <ul>
                                        <li>ê·œì¹™ì ì¸ ì„¸í¬ í˜•íƒœ</li>
                                        <li>ê· ì¼í•œ í•µ í¬ê¸°</li>
                                        <li>ëª…í™•í•œ ì„¸í¬ ê²½ê³„</li>
                                        <li>ì •ìƒì ì¸ ì„¸í¬ ë°°ì—´</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="example-card malignant-example">
                        <div class="example-header">
                            <div class="example-badge malignant-badge">ì•…ì„± (Malignant)</div>
                        </div>
                        <div class="example-image-container">
                            <img src="{{ url_for('static', filename='images/malignant_ex.png') }}" alt="ì•…ì„± ì„¸í¬ ì˜ˆì‹œ" class="example-image">
                            <div class="image-overlay">
                                <div class="overlay-content">
                                    <h3>ì•…ì„± ì„¸í¬ íŠ¹ì§•</h3>
                                    <ul>
                                        <li>ë¶ˆê·œì¹™í•œ ì„¸í¬ í˜•íƒœ</li>
                                        <li>ë‹¤ì–‘í•œ í•µ í¬ê¸°</li>
                                        <li>ë¶ˆëª…í™•í•œ ì„¸í¬ ê²½ê³„</li>
                                        <li>ë¹„ì •ìƒì ì¸ ì„¸í¬ ë°°ì—´</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="comparison-section">
                <h2>ğŸ”¬ ì„¸í¬ ê²€ì¶œ ë°©ë²• ë¹„êµ ì‹œê°í™”</h2>
                <div class="comparison-loading" id="comparisonLoading" style="display: none;">
                    <div class="spinner-small"></div>
                    <p>ë¹„êµ ì‹œê°í™” ìƒì„± ì¤‘...</p>
                </div>
                <div class="comparison-container" id="comparisonContainer">
                    <img id="comparisonImage" src="" alt="ë¹„êµ ì‹œê°í™”" style="display: none; width: 100%; height: auto; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.2);">
                </div>
            </div>

            <div class="upload-section">
                <h2>ì´ë¯¸ì§€ ì—…ë¡œë“œ</h2>
                <div class="upload-box" id="uploadBox">
                    <input type="file" id="imageInput" accept="image/*,.tif,.TIF" style="display: none;">
                    <div class="upload-area" onclick="document.getElementById('imageInput').click()">
                        <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                        <p>ì´ë¯¸ì§€ë¥¼ í´ë¦­í•˜ê±°ë‚˜ ë“œë˜ê·¸í•˜ì—¬ ì—…ë¡œë“œ</p>
                        <p class="file-info">ì§€ì› í˜•ì‹: JPG, PNG, TIF</p>
                    </div>
                </div>
                <div id="fileName" class="file-name"></div>
            </div>

            <div class="results-section" id="resultsSection" style="display: none;">
                <h2>ë¶„ì„ ê²°ê³¼</h2>
                
                <div class="prediction-card">
                    <div class="prediction-header">
                        <h3>ì˜ˆì¸¡ ê²°ê³¼</h3>
                        <div class="prediction-method" id="predictionMethod" style="display: none;">
                            <span class="method-tag" id="methodTag">CNN</span>
                        </div>
                    </div>
                    <div class="prediction-content">
                        <div class="prediction-badge" id="predictionBadge">
                            <span id="predictionText">-</span>
                            <span id="predictionProb">-</span>
                        </div>
                        <div class="actual-label" id="actualLabel" style="display: none;">
                            <span class="label-text">ì‹¤ì œ ë ˆì´ë¸”: </span>
                            <span class="label-value" id="actualLabelValue">-</span>
                        </div>
                        <div class="probability-bars">
                            <div class="prob-bar">
                                <label>ì•…ì„± (M)</label>
                                <div class="bar-container">
                                    <div class="bar malignant" id="malignantBar"></div>
                                    <span id="malignantProb">0%</span>
                                </div>
                            </div>
                            <div class="prob-bar">
                                <label>ì–‘ì„± (B)</label>
                                <div class="bar-container">
                                    <div class="bar benign" id="benignBar"></div>
                                    <span id="benignProb">0%</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="image-result">
                    <div class="image-header">
                        <h3>ì„¸í¬ ê°ì§€ ê²°ê³¼</h3>
                    </div>
                    <div class="image-container" id="imageContainer">
                        <div class="image-wrapper" id="imageWrapper">
                            <img id="resultImage" src="" alt="ë¶„ì„ ê²°ê³¼ ì´ë¯¸ì§€" style="display: block; max-width: 100%; height: auto;">
                            <canvas id="resultCanvas" style="display: none;"></canvas>
                        </div>
                    </div>
                    <div class="legend">
                        <div class="legend-item">
                            <span class="legend-color malignant"></span>
                            <span>ì•…ì„± ì„¸í¬</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color benign"></span>
                            <span>ì–‘ì„± ì„¸í¬</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color segmentation"></span>
                            <span>ì„¸í¬ ê²½ê³„</span>
                        </div>
                    </div>
                </div>

                <div class="segmentation-result">
                    <h3>Cell Segmentation Visualization</h3>
                    <p class="segmentation-intro">ê° ì„¸í¬ê°€ ê³ ìœ í•œ ìƒ‰ìƒìœ¼ë¡œ êµ¬ë¶„ë˜ì–´ í‘œì‹œë©ë‹ˆë‹¤. ê²½ê³„ì„  ìƒ‰ìƒì€ ì˜ˆì¸¡ ê²°ê³¼ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤ (ë¹¨ê°•: ì•…ì„±, ì´ˆë¡: ì–‘ì„±).</p>
                    <div class="image-container" id="segmentationContainer">
                        <div class="image-wrapper" id="segmentationWrapper">
                            <img id="segmentationImage" src="" alt="Segmentation ì‹œê°í™” ì´ë¯¸ì§€">
                        </div>
                    </div>
                </div>

                <div class="mask-segmentation-result" id="maskSegmentationResult" style="display: none;">
                    <h3>Mask file-based cell boundary visualization</h3>
                    <p class="segmentation-intro">Masks í´ë”ì˜ ë§ˆìŠ¤í¬ íŒŒì¼ì„ ì§ì ‘ ì‚¬ìš©í•˜ì—¬ ì¶”ì¶œí•œ ì •í™•í•œ ì„¸í¬ ê²½ê³„ì…ë‹ˆë‹¤. ê° ì„¸í¬ê°€ ê³ ìœ í•œ ìƒ‰ìƒìœ¼ë¡œ êµ¬ë¶„ë˜ì–´ í‘œì‹œë©ë‹ˆë‹¤.</p>
                    <div class="image-container" id="maskSegmentationContainer">
                        <div class="image-wrapper" id="maskSegmentationWrapper">
                            <img id="maskSegmentationImage" src="" alt="ë§ˆìŠ¤í¬ ê¸°ë°˜ Segmentation ì‹œê°í™” ì´ë¯¸ì§€">
                        </div>
                    </div>
                </div>

                <div class="explanation-card">
                    <h3>ğŸ“Š íŒë‹¨ ê·¼ê±° (XAI ë¶„ì„)</h3>
                    <p class="explanation-intro">ë‹¤ìŒ íŠ¹ì§•ë“¤ì´ ì˜ˆì¸¡ ê²°ê³¼ì— ê°€ì¥ í° ì˜í–¥ì„ ë¯¸ì³¤ìŠµë‹ˆë‹¤:</p>
                    <div class="explanation-method" id="explanationMethod" style="display: none;">
                        <span class="method-badge" id="methodBadge">SHAP</span>
                    </div>
                    <div class="features-list" id="featuresList">
                        <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
                    </div>
                </div>

                <div class="features-card">
                    <h3>ğŸ” ì¶”ì¶œëœ íŠ¹ì§• ê°’</h3>
                    <div class="features-grid" id="featuresGrid">
                        <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
                    </div>
                </div>

                <div class="vlm-explanation-card">
                    <h3>ğŸ¤– AI ì´ë¯¸ì§€ ë¶„ì„ ì„¤ëª… (VLM)</h3>
                    <div class="vlm-loading" id="vlmLoading" style="display: none;">
                        <div class="spinner-small"></div>
                        <p>AIê°€ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•˜ê³  ì„¤ëª…ì„ ìƒì„±í•˜ëŠ” ì¤‘...</p>
                    </div>
                    <div class="vlm-content" id="vlmContent">
                        <div class="vlm-explanation-text" id="vlmExplanation">
                            <!-- VLM ì„¤ëª…ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
                        </div>
                    </div>
                </div>
            </div>

            <div class="loading" id="loading" style="display: none;">
                <div class="spinner"></div>
                <p>ì´ë¯¸ì§€ ë¶„ì„ ì¤‘...</p>
            </div>
        </main>

        <div class="creator-section">
            <h2>ğŸ‘¨â€ğŸ’» Developer</h2>
            <div class="creator-card">
                <div class="creator-image-container">
                    <img src="{{ url_for('static', filename='images/hae.png') }}" alt="ì„œí•´ì¸" class="creator-image">
                    <div class="creator-glow"></div>
                </div>
                <div class="creator-info">
                    <h3>ì„œí•´ì¸ (Seo Hae In)</h3>
                    <p class="creator-org">ë•ì„±ì—¬ìëŒ€í•™êµ ë°ì´í„°ì‚¬ì´ì–¸ìŠ¤í•™ê³¼</p>
                    <p class="creator-org-en">Duksung Women's University<br>Department of Data Science</p>
                    <div class="creator-badges">
                        <span class="badge">Data Science</span>
                        <span class="badge">AI/ML</span>
                        <span class="badge">Computer Vision</span>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <p>Â© 2025 ìœ ë°©ì•” ì´ë¯¸ì§€ ë¶„ì„ ì‹œìŠ¤í…œ | XAI ê¸°ë°˜ ì„¤ëª… ê°€ëŠ¥í•œ AI</p>
            <p class="footer-sub">Developed by Hae-In Seo</p>
        </footer>
    </div>

    <script>
        const imageInput = document.getElementById('imageInput');
        const uploadBox = document.getElementById('uploadBox');
        const fileName = document.getElementById('fileName');
        const resultsSection = document.getElementById('resultsSection');
        const loading = document.getElementById('loading');

        // íŒŒì¼ ì„ íƒ ì´ë²¤íŠ¸
        imageInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                fileName.textContent = `ì„ íƒëœ íŒŒì¼: ${file.name}`;
                fileName.style.display = 'block';
                
                // ìë™ìœ¼ë¡œ ë¶„ì„ ì‹œì‘
                analyzeImage(file);
            }
        });

        // ë“œë˜ê·¸ ì•¤ ë“œë¡­
        const uploadArea = uploadBox.querySelector('.upload-area');
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) {
                imageInput.files = e.dataTransfer.files;
                fileName.textContent = `ì„ íƒëœ íŒŒì¼: ${file.name}`;
                fileName.style.display = 'block';
                analyzeImage(file);
            }
        });

        // ì´ë¯¸ì§€ ë¶„ì„ í•¨ìˆ˜
        async function analyzeImage(file) {
            const formData = new FormData();
            formData.append('image', file);

            loading.style.display = 'block';
            resultsSection.style.display = 'none';

            try {
                const response = await fetch('/predict', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (response.ok) {
                    displayResults(data);
                } else {
                    alert('ì˜¤ë¥˜: ' + (data.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'));
                }
            } catch (error) {
                alert('ì˜¤ë¥˜: ' + error.message);
            } finally {
                loading.style.display = 'none';
                resultsSection.style.display = 'block';
            }
        }

        // ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
        function displayResults(data) {
            // ì˜ˆì¸¡ ê²°ê³¼
            const predictionText = document.getElementById('predictionText');
            const predictionProb = document.getElementById('predictionProb');
            const predictionBadge = document.getElementById('predictionBadge');
            const predictionMethod = document.getElementById('predictionMethod');
            const methodTag = document.getElementById('methodTag');
            const actualLabel = document.getElementById('actualLabel');
            const actualLabelValue = document.getElementById('actualLabelValue');
            
            predictionText.textContent = data.prediction;
            predictionProb.textContent = `(${(data.probability * 100).toFixed(2)}%)`;
            
            if (data.prediction.includes('ì•…ì„±')) {
                predictionBadge.className = 'prediction-badge malignant';
                predictionText.className = 'malignant-text';
                predictionProb.className = 'malignant-text';
            } else {
                predictionBadge.className = 'prediction-badge benign';
                predictionText.className = 'benign-text';
                predictionProb.className = 'benign-text';
            }
            
            // ì˜ˆì¸¡ ë°©ë²• í‘œì‹œ
            if (data.prediction_method) {
                predictionMethod.style.display = 'block';
                methodTag.textContent = data.prediction_method;
            }
            
            // ì‹¤ì œ ë ˆì´ë¸” í‘œì‹œ (íŒŒì¼ëª… ê¸°ë°˜)
            if (data.actual_label) {
                actualLabel.style.display = 'block';
                actualLabelValue.textContent = data.actual_label;
                
                // ì •í™•ë„ í‘œì‹œ ë° ìƒ‰ìƒ ì„¤ì •
                const isCorrect = data.actual_label === data.prediction;
                if (data.actual_label.includes('ì•…ì„±')) {
                    actualLabelValue.className = 'label-value malignant-label';
                } else if (data.actual_label.includes('ì–‘ì„±')) {
                    actualLabelValue.className = 'label-value benign-label';
                } else {
                    actualLabelValue.className = 'label-value ' + (isCorrect ? 'correct' : 'incorrect');
                }
            }

            // í™•ë¥  ë°”
            const malignantProb = (data.malignant_prob * 100).toFixed(1);
            const benignProb = (data.benign_prob * 100).toFixed(1);
            
            document.getElementById('malignantBar').style.width = malignantProb + '%';
            document.getElementById('malignantProb').textContent = malignantProb + '%';
            document.getElementById('benignBar').style.width = benignProb + '%';
            document.getElementById('benignProb').textContent = benignProb + '%';

            // ì´ë¯¸ì§€ ì§ì ‘ í‘œì‹œ (í™•ëŒ€ ê¸°ëŠ¥ ì œê±°)
            const resultImage = document.getElementById('resultImage');
            const resultCanvas = document.getElementById('resultCanvas');
            
            // ê²°ê³¼ ì´ë¯¸ì§€ ì§ì ‘ í‘œì‹œ (bbox í¬í•¨ëœ ì´ë¯¸ì§€)
            if (data.image) {
                resultImage.src = data.image;
                resultImage.style.display = 'block';
                resultCanvas.style.display = 'none';
            }
            
            // Segmentation ì´ë¯¸ì§€ í‘œì‹œ
            if (data.segmentation_image) {
                const segImage = document.getElementById('segmentationImage');
                if (segImage) {
                    segImage.src = data.segmentation_image;
                    
                    // Segmentation ì´ë¯¸ì§€ë„ ì¤Œ ê¸°ëŠ¥ ì ìš©
                    segImage.onload = function() {
                        initSegmentationZoom();
                    };
                }
            }
            
            // ë§ˆìŠ¤í¬ ê¸°ë°˜ Segmentation ì´ë¯¸ì§€ í‘œì‹œ
            if (data.mask_based_image) {
                const maskSegResult = document.getElementById('maskSegmentationResult');
                const maskSegImage = document.getElementById('maskSegmentationImage');
                if (maskSegResult && maskSegImage) {
                    maskSegResult.style.display = 'block';
                    maskSegImage.src = data.mask_based_image;
                    
                    // ë§ˆìŠ¤í¬ ê¸°ë°˜ ì´ë¯¸ì§€ë„ ì¤Œ ê¸°ëŠ¥ ì ìš©
                    maskSegImage.onload = function() {
                        initMaskSegmentationZoom();
                    };
                }
            } else {
                const maskSegResult = document.getElementById('maskSegmentationResult');
                if (maskSegResult) {
                    maskSegResult.style.display = 'none';
                }
            }

            // ì„¤ëª… ë°©ë²• í‘œì‹œ
            const explanationMethod = document.getElementById('explanationMethod');
            const methodBadge = document.getElementById('methodBadge');
            if (data.explanation && data.explanation.method) {
                explanationMethod.style.display = 'block';
                const method = data.explanation.method;
                methodBadge.textContent = method;
                methodBadge.className = 'method-badge ' + method.toLowerCase().replace(' ', '-');
            } else {
                explanationMethod.style.display = 'none';
            }

            // SHAP/LIME ì„¤ëª…
            const featuresList = document.getElementById('featuresList');
            featuresList.innerHTML = '';
            
            if (data.explanation && data.explanation.top_features) {
                data.explanation.top_features.forEach((feat, index) => {
                    const item = document.createElement('div');
                    item.className = 'feature-item';
                    
                    const contribution = feat.contribution;
                    const isPositive = contribution > 0;
                    
                    item.innerHTML = `
                        <div class="feature-rank">${index + 1}</div>
                        <div class="feature-info">
                            <div class="feature-name">${feat.feature}</div>
                            <div class="feature-contribution ${isPositive ? 'positive' : 'negative'}">
                                ${isPositive ? '+' : ''}${contribution.toFixed(4)}
                            </div>
                        </div>
                        <div class="feature-bar">
                            <div class="feature-bar-fill ${isPositive ? 'positive' : 'negative'}" 
                                 style="width: ${Math.abs(contribution) * 100}%"></div>
                        </div>
                    `;
                    featuresList.appendChild(item);
                });
            }

            // íŠ¹ì§• ê°’ ê·¸ë¦¬ë“œ
            const featuresGrid = document.getElementById('featuresGrid');
            featuresGrid.innerHTML = '';
            
            if (data.features) {
                Object.entries(data.features).forEach(([name, value]) => {
                    const item = document.createElement('div');
                    item.className = 'feature-value-item';
                    item.innerHTML = `
                        <div class="feature-value-name">${name}</div>
                        <div class="feature-value-number">${value.toFixed(4)}</div>
                    `;
                    featuresGrid.appendChild(item);
                });
            }

            // VLM ì„¤ëª… í‘œì‹œ
            const vlmExplanation = document.getElementById('vlmExplanation');
            const vlmLoading = document.getElementById('vlmLoading');
            const vlmContent = document.getElementById('vlmContent');
            
            // ë””ë²„ê¹…: ì½˜ì†”ì— ìƒì„¸ ì •ë³´ ì¶œë ¥
            console.log('='.repeat(60));
            console.log('ğŸ” VLM ì„¤ëª… ë°ì´í„° í™•ì¸');
            console.log('='.repeat(60));
            console.log('âœ… VLM ì„¤ëª… ì¡´ì¬ ì—¬ë¶€:', !!data.vlm_explanation);
            console.log('ğŸ“Š VLM ì„¤ëª… íƒ€ì…:', typeof data.vlm_explanation);
            console.log('ğŸ“ VLM ì„¤ëª… ê¸¸ì´:', data.vlm_explanation ? data.vlm_explanation.length : 0);
            console.log('ğŸ“ VLM ì„¤ëª… ë‚´ìš© (ì²˜ìŒ 300ì):', data.vlm_explanation ? data.vlm_explanation.substring(0, 300) : 'ì—†ìŒ');
            console.log('ğŸ“ VLM ì„¤ëª… ì „ì²´:', data.vlm_explanation);
            console.log('='.repeat(60));
            
            if (data.vlm_explanation && data.vlm_explanation.trim().length > 0) {
                vlmLoading.style.display = 'none';
                vlmContent.style.display = 'block';
                // ë§ˆí¬ë‹¤ìš´ í˜•ì‹ì˜ í…ìŠ¤íŠ¸ë¥¼ HTMLë¡œ ë³€í™˜
                const explanationHtml = formatVLMExplanation(data.vlm_explanation);
                console.log('âœ… í¬ë§·íŒ…ëœ HTML (ì²˜ìŒ 500ì):', explanationHtml.substring(0, 500));
                vlmExplanation.innerHTML = explanationHtml;
                console.log('âœ… VLM ì„¤ëª…ì´ í™”ë©´ì— í‘œì‹œë˜ì—ˆìŠµë‹ˆë‹¤.');
            } else {
                // VLM ì„¤ëª…ì´ ì—†ìœ¼ë©´ ë¡œë”© í‘œì‹œ
                vlmLoading.style.display = 'none';
                vlmContent.style.display = 'block';
                vlmExplanation.innerHTML = '<p style="color: #ff6b6b;">âš ï¸ VLM ì„¤ëª…ì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>';
                console.warn('âŒ VLM ì„¤ëª…ì´ ì—†ê±°ë‚˜ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.');
                console.warn('ì „ì²´ ì‘ë‹µ ë°ì´í„°:', data);
            }
        }

        // ì´ë¯¸ì§€ ì¤Œ/íŒ¨ë‹ ê¸°ëŠ¥
        let zoomLevel = 1;
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let isSegmentationVisible = false; // ì²« ì°½ì—ì„œëŠ” segmentation ë¹„í™œì„±í™”
        let boxesData = [];
        let baseImageObj = null;
        
        // Canvasì— ë°•ìŠ¤ ê·¸ë¦¬ê¸° í•¨ìˆ˜
        function drawBoxesOnCanvas(ctx, boxes, imgWidth, imgHeight) {
            boxesData = boxes; // ì „ì—­ ë³€ìˆ˜ì— ì €ì¥
            
            // í™•ëŒ€ ë ˆë²¨ì— ë”°ë¼ ë°•ìŠ¤ ìœ„ì¹˜ ì¡°ì •
            const adjustedBoxes = adjustBoxPositionsForZoom(boxes, zoomLevel, imgWidth, imgHeight);
            
            adjustedBoxes.forEach((box, idx) => {
                const [x, y, w, h] = box.bbox;
                const color = box.color;
                const isMalignant = box.is_malignant;
                
                // Bounding box ê·¸ë¦¬ê¸°
                ctx.strokeStyle = color;
                ctx.lineWidth = zoomLevel > 1.5 ? 3 : 2;
                ctx.globalAlpha = 0.8;
                ctx.strokeRect(x, y, w, h);
                
                // ë°˜íˆ¬ëª… ì±„ìš°ê¸°
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.2;
                ctx.fillRect(x, y, w, h);
                
                // Segmentation (contours) ê·¸ë¦¬ê¸° - ì²« ì°½ì—ì„œëŠ” ì œê±°ë¨
                // segmentationì€ ë³„ë„ì˜ segmentation-result ì„¹ì…˜ì—ì„œë§Œ í‘œì‹œ
                
                // ë ˆì´ë¸” ê·¸ë¦¬ê¸°
                const labelX = box.adjustedX !== undefined ? box.adjustedX : x;
                const labelY = box.adjustedY !== undefined ? box.adjustedY : y - 5;
                
                // ë ˆì´ë¸” í…ìŠ¤íŠ¸ êµ¬ì„±
                let labelText = `${box.label} (${(box.probability * 100).toFixed(1)}%)`;
                if (box.top_features && box.top_features.length > 0) {
                    const topFeat = box.top_features[0];
                    const shortName = topFeat.feature.replace(/_mean|_worst|_se/g, '');
                    labelText += `\n${shortName.substring(0, 15)}(${topFeat.contribution > 0 ? '+' : ''}${topFeat.contribution.toFixed(2)})`;
                }
                
                // ë ˆì´ë¸” ë°°ê²½
                const labelLines = labelText.split('\n');
                const labelHeight = labelLines.length * 16 + 8;
                const labelWidth = Math.max(...labelLines.map(l => l.length * 8)) + 12;
                
                ctx.fillStyle = 'white';
                ctx.globalAlpha = 0.95;
                ctx.fillRect(labelX - 2, labelY - labelHeight - 2, labelWidth, labelHeight);
                
                // ë ˆì´ë¸” í…Œë‘ë¦¬
                ctx.strokeStyle = color;
                ctx.lineWidth = 2.5;
                ctx.globalAlpha = 1;
                ctx.strokeRect(labelX - 2, labelY - labelHeight - 2, labelWidth, labelHeight);
                
                // ë ˆì´ë¸” í…ìŠ¤íŠ¸
                ctx.fillStyle = isMalignant ? '#cc0000' : '#006600';
                ctx.font = `bold ${zoomLevel > 1.5 ? 10 : 8}px Arial`;
                ctx.globalAlpha = 1;
                labelLines.forEach((line, i) => {
                    ctx.fillText(line, labelX + 4, labelY - labelHeight + 16 + (i * 16));
                });
            });
        }
        
        // í™•ëŒ€ ì‹œ ë°•ìŠ¤ ìœ„ì¹˜ ì¡°ì • (ê²¹ì¹¨ ë°©ì§€ - ê°œì„ ëœ ë²„ì „)
        function adjustBoxPositionsForZoom(boxes, zoom, imgWidth, imgHeight) {
            if (zoom <= 1.0) {
                // í™•ëŒ€ê°€ ì—†ìœ¼ë©´ ì›ë˜ ìœ„ì¹˜ ì‚¬ìš©
                return boxes.map(box => ({ ...box, adjustedX: undefined, adjustedY: undefined }));
            }
            
            // í™•ëŒ€ ë ˆë²¨ì— ë”°ë¼ ë ˆì´ë¸” í¬ê¸° ì¡°ì •
            const labelHeight = Math.max(40, 50 * zoom); // ì¤Œì— ë”°ë¼ ë ˆì´ë¸” ë†’ì´ ì¦ê°€
            const labelWidth = Math.max(120, 150 * zoom); // ì¤Œì— ë”°ë¼ ë ˆì´ë¸” ë„ˆë¹„ ì¦ê°€
            const minSpacing = 15 * zoom; // ìµœì†Œ ê°„ê²©ë„ ì¤Œì— ë”°ë¼ ì¦ê°€
            
            // í™•ëŒ€ê°€ í¬ë©´ ë ˆì´ë¸” ìœ„ì¹˜ ì¡°ì •
            const adjusted = boxes.map((box, idx) => {
                const [x, y, w, h] = box.bbox;
                let adjustedX = x;
                let adjustedY = y - 5;
                
                // ì¤Œ ë ˆë²¨ì— ë”°ë¼ ì˜¤í”„ì…‹ ì¡°ì •
                const zoomOffset = (zoom - 1) * 10;
                
                // ë‹¤ë¥¸ ë°•ìŠ¤ë“¤ê³¼ì˜ ê²¹ì¹¨ í™•ì¸ ë° ì¡°ì • (ë” ì •êµí•œ ì•Œê³ ë¦¬ì¦˜)
                let attempts = 0;
                const maxAttempts = 20;
                
                while (attempts < maxAttempts) {
                    let hasCollision = false;
                    
                    // ì´ì „ì— ë°°ì¹˜ëœ ëª¨ë“  ë°•ìŠ¤ì™€ ì¶©ëŒ í™•ì¸
                    for (let i = 0; i < idx; i++) {
                        const otherBox = adjusted[i];
                        const [ox, oy, ow, oh] = otherBox.bbox;
                        const otherLabelY = otherBox.adjustedY !== undefined ? otherBox.adjustedY : oy - 5;
                        const otherLabelX = otherBox.adjustedX !== undefined ? otherBox.adjustedX : ox;
                        
                        // ë ˆì´ë¸” ì˜ì—­ ê³„ì‚°
                        const thisLabelLeft = adjustedX;
                        const thisLabelRight = adjustedX + labelWidth;
                        const thisLabelTop = adjustedY - labelHeight;
                        const thisLabelBottom = adjustedY;
                        
                        const otherLabelLeft = otherLabelX;
                        const otherLabelRight = otherLabelX + labelWidth;
                        const otherLabelTop = otherLabelY - labelHeight;
                        const otherLabelBottom = otherLabelY;
                        
                        // ê²¹ì¹¨ í™•ì¸ (ë” ì •í™•í•œ ì˜ì—­ ê¸°ë°˜)
                        const horizontalOverlap = !(thisLabelRight < otherLabelLeft || thisLabelLeft > otherLabelRight);
                        const verticalOverlap = !(thisLabelBottom < otherLabelTop || thisLabelTop > otherLabelBottom);
                        
                        if (horizontalOverlap && verticalOverlap) {
                            hasCollision = true;
                            
                            // ì¶©ëŒ ë°©ì§€ ì „ëµ: ì—¬ëŸ¬ ë°©í–¥ ì‹œë„
                            if (attempts % 4 === 0) {
                                // ìœ„ë¡œ ì´ë™
                                adjustedY = otherLabelTop - minSpacing;
                            } else if (attempts % 4 === 1) {
                                // ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™
                                adjustedX = otherLabelRight + minSpacing;
                            } else if (attempts % 4 === 2) {
                                // ì•„ë˜ë¡œ ì´ë™ (ë°•ìŠ¤ ì•„ë˜)
                                adjustedY = y + h + minSpacing;
                            } else {
                                // ì™¼ìª½ìœ¼ë¡œ ì´ë™
                                adjustedX = otherLabelLeft - labelWidth - minSpacing;
                            }
                            break;
                        }
                    }
                    
                    if (!hasCollision) {
                        break;
                    }
                    
                    attempts++;
                }
                
                // ì´ë¯¸ì§€ ê²½ê³„ í™•ì¸ ë° ì¡°ì •
                adjustedY = Math.max(10, Math.min(adjustedY, imgHeight - labelHeight - 10));
                adjustedX = Math.max(5, Math.min(adjustedX, imgWidth - labelWidth - 5));
                
                // ë°•ìŠ¤ ì˜ì—­ê³¼ ê²¹ì¹˜ì§€ ì•Šë„ë¡ ì¡°ì •
                if (adjustedY > y && adjustedY < y + h) {
                    adjustedY = y + h + minSpacing;
                }
                if (adjustedX > x && adjustedX < x + w) {
                    adjustedX = x + w + minSpacing;
                }
                
                return { ...box, adjustedX, adjustedY };
            });
            
            return adjusted;
        }
        
        function initZoomPan() {
            const imageWrapper = document.getElementById('imageWrapper');
            const resultCanvas = document.getElementById('resultCanvas');
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const resetZoomBtn = document.getElementById('resetZoomBtn');
            const toggleSegmentationBtn = document.getElementById('toggleSegmentationBtn');
            
            if (!imageWrapper || !resultCanvas) return;
            
            // ì¤Œ ì¸
            zoomInBtn.addEventListener('click', () => {
                zoomLevel = Math.min(zoomLevel * 1.5, 5);
                updateCanvasTransform();
            });
            
            // ì¤Œ ì•„ì›ƒ
            zoomOutBtn.addEventListener('click', () => {
                zoomLevel = Math.max(zoomLevel / 1.5, 0.5);
                updateCanvasTransform();
            });
            
            // ë¦¬ì…‹
            resetZoomBtn.addEventListener('click', () => {
                zoomLevel = 1;
                panX = 0;
                panY = 0;
                updateCanvasTransform();
            });
            
            // ì„¸í¬ ê²½ê³„ í† ê¸€
            toggleSegmentationBtn.addEventListener('click', () => {
                isSegmentationVisible = !isSegmentationVisible;
                toggleSegmentationBtn.style.opacity = isSegmentationVisible ? '1' : '0.5';
                updateCanvasTransform();
            });
            
            // ë§ˆìš°ìŠ¤ íœ ë¡œ ì¤Œ (ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ê¸°ì¤€)
            imageWrapper.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                const rect = imageWrapper.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const oldZoom = zoomLevel;
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                zoomLevel = Math.max(0.5, Math.min(5, zoomLevel * delta));
                
                // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ì¤Œ
                const zoomChange = zoomLevel / oldZoom;
                panX = mouseX - (mouseX - panX) * zoomChange;
                panY = mouseY - (mouseY - panY) * zoomChange;
                
                updateCanvasTransform();
            });
            
            // ë“œë˜ê·¸ë¡œ íŒ¨ë‹
            imageWrapper.addEventListener('mousedown', (e) => {
                if (zoomLevel > 1) {
                    isDragging = true;
                    dragStartX = e.clientX - panX;
                    dragStartY = e.clientY - panY;
                    imageWrapper.style.cursor = 'grabbing';
                }
            });
            
            imageWrapper.addEventListener('mousemove', (e) => {
                if (isDragging && zoomLevel > 1) {
                    panX = e.clientX - dragStartX;
                    panY = e.clientY - dragStartY;
                    updateCanvasTransform();
                }
            });
            
            imageWrapper.addEventListener('mouseup', () => {
                isDragging = false;
                imageWrapper.style.cursor = zoomLevel > 1 ? 'grab' : 'default';
            });
            
            imageWrapper.addEventListener('mouseleave', () => {
                isDragging = false;
                imageWrapper.style.cursor = 'default';
            });
        }
        
        function updateCanvasTransform() {
            const resultCanvas = document.getElementById('resultCanvas');
            const imageWrapper = document.getElementById('imageWrapper');
            if (!resultCanvas || !imageWrapper) return;
            
            // Canvas ë³€í™˜
            resultCanvas.style.transform = `scale(${zoomLevel}) translate(${panX / zoomLevel}px, ${panY / zoomLevel}px)`;
            resultCanvas.style.transformOrigin = 'top left';
            
            // Canvas ë‹¤ì‹œ ê·¸ë¦¬ê¸° (ë°•ìŠ¤ ìœ„ì¹˜ ë™ì  ì¡°ì •)
            if (baseImageObj && boxesData.length > 0) {
                const ctx = resultCanvas.getContext('2d');
                ctx.clearRect(0, 0, resultCanvas.width, resultCanvas.height);
                ctx.drawImage(baseImageObj, 0, 0);
                drawBoxesOnCanvas(ctx, boxesData, resultCanvas.width, resultCanvas.height);
            }
        }
        
        
        // Segmentation ì´ë¯¸ì§€ ì¤Œ/íŒ¨ë‹ ê¸°ëŠ¥
        let segZoomLevel = 1;
        let segPanX = 0;
        let segPanY = 0;
        let segIsDragging = false;
        let segDragStartX = 0;
        let segDragStartY = 0;
        
        function initSegmentationZoom() {
            const segWrapper = document.getElementById('segmentationWrapper');
            const segImage = document.getElementById('segmentationImage');
            if (!segWrapper || !segImage) return;
            
            // ë§ˆìš°ìŠ¤ íœ ë¡œ ì¤Œ
            segWrapper.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                const rect = segWrapper.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const oldZoom = segZoomLevel;
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                segZoomLevel = Math.max(0.5, Math.min(5, segZoomLevel * delta));
                
                const zoomChange = segZoomLevel / oldZoom;
                segPanX = mouseX - (mouseX - segPanX) * zoomChange;
                segPanY = mouseY - (mouseY - segPanY) * zoomChange;
                
                updateSegmentationTransform();
            });
            
            // ë“œë˜ê·¸ë¡œ íŒ¨ë‹
            segWrapper.addEventListener('mousedown', (e) => {
                if (segZoomLevel > 1) {
                    segIsDragging = true;
                    segDragStartX = e.clientX - segPanX;
                    segDragStartY = e.clientY - segPanY;
                    segWrapper.style.cursor = 'grabbing';
                }
            });
            
            segWrapper.addEventListener('mousemove', (e) => {
                if (segIsDragging && segZoomLevel > 1) {
                    segPanX = e.clientX - segDragStartX;
                    segPanY = e.clientY - segDragStartY;
                    updateSegmentationTransform();
                }
            });
            
            segWrapper.addEventListener('mouseup', () => {
                segIsDragging = false;
                segWrapper.style.cursor = segZoomLevel > 1 ? 'grab' : 'default';
            });
            
            segWrapper.addEventListener('mouseleave', () => {
                segIsDragging = false;
                segWrapper.style.cursor = 'default';
            });
        }
        
        function updateSegmentationTransform() {
            const segImage = document.getElementById('segmentationImage');
            if (!segImage) return;
            
            segImage.style.transform = `scale(${segZoomLevel}) translate(${segPanX / segZoomLevel}px, ${segPanY / segZoomLevel}px)`;
            segImage.style.transformOrigin = 'top left';
        }
        
        // VLM ì„¤ëª… í¬ë§·íŒ… í•¨ìˆ˜
        function formatVLMExplanation(text) {
            if (!text) return '<p>ì„¤ëª…ì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>';
            
            // ë§ˆí¬ë‹¤ìš´ í˜•ì‹ì˜ í…ìŠ¤íŠ¸ë¥¼ HTMLë¡œ ë³€í™˜
            let html = text;
            
            // í—¤ë” ë³€í™˜ (# -> <h4>, ## -> <h5>)
            html = html.replace(/^### (.*$)/gim, '<h4>$1</h4>');
            html = html.replace(/^## (.*$)/gim, '<h5>$1</h5>');
            html = html.replace(/^# (.*$)/gim, '<h4>$1</h4>');
            
            // ë³¼ë“œ ë³€í™˜ (**text** -> <strong>text</strong>)
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // ë¦¬ìŠ¤íŠ¸ ë³€í™˜ (- -> <li>)
            html = html.replace(/^- (.*$)/gim, '<li>$1</li>');
            html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
            
            // ì¤„ë°”ê¿ˆ ì²˜ë¦¬
            html = html.replace(/\n\n/g, '</p><p>');
            html = html.replace(/\n/g, '<br>');
            
            // ë¬¸ë‹¨ íƒœê·¸ ì¶”ê°€
            if (!html.startsWith('<')) {
                html = '<p>' + html + '</p>';
            }
            
            return html;
        }

        // ë¹„êµ ì‹œê°í™” ë¡œë“œ
        async function loadComparisonVisualization() {
            const comparisonLoading = document.getElementById('comparisonLoading');
            const comparisonImage = document.getElementById('comparisonImage');
            const comparisonContainer = document.getElementById('comparisonContainer');
            
            try {
                comparisonLoading.style.display = 'block';
                comparisonImage.style.display = 'none';
                
                const response = await fetch('/comparison_visualization');
                const data = await response.json();
                
                if (response.ok && data.image) {
                    comparisonImage.src = data.image;
                    comparisonImage.style.display = 'block';
                } else {
                    comparisonContainer.innerHTML = '<p style="color: #ff6b6b; text-align: center; padding: 20px;">ë¹„êµ ì‹œê°í™”ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>';
                }
            } catch (error) {
                console.error('ë¹„êµ ì‹œê°í™” ë¡œë“œ ì˜¤ë¥˜:', error);
                comparisonContainer.innerHTML = '<p style="color: #ff6b6b; text-align: center; padding: 20px;">ë¹„êµ ì‹œê°í™”ë¥¼ ë¡œë“œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</p>';
            } finally {
                comparisonLoading.style.display = 'none';
            }
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ë¹„êµ ì‹œê°í™” ìë™ ë¡œë“œ
        window.addEventListener('DOMContentLoaded', () => {
            loadComparisonVisualization();
        });
    </script>
</body>
</html>

